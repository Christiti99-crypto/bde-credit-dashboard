<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indicadores de Cartera de Cr√©dito - BDE</title>
    
    <!-- Cargar XLSX PRIMERO antes que todo -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            background: white;
            border-radius: 15px;
            padding: 8px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .tab {
            flex: 1;
            padding: 15px 25px;
            text-align: center;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .tab:hover:not(.active) {
            background: #f8f9fa;
            transform: translateY(-1px);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 25px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .card h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            width: 100%;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-display {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            border: 2px dashed #667eea;
            border-radius: 12px;
            background: #f8f9ff;
            transition: all 0.3s ease;
            min-height: 60px;
        }

        .file-input-display:hover {
            border-color: #764ba2;
            background: #f0f4ff;
            transform: scale(1.02);
        }

        .file-icon {
            font-size: 24px;
            color: #667eea;
        }

        .file-text {
            flex: 1;
            color: #666;
        }

        .file-text.has-file {
            color: #2c3e50;
            font-weight: 600;
        }

        select, input[type="radio"] {
            margin-right: 8px;
        }

        select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-size: 16px;
            background: white;
            transition: border-color 0.3s ease;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .radio-option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .radio-option.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .radio-option input[type="radio"] {
            margin-right: 12px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status-box {
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            margin: 20px 0;
            border: 2px solid;
        }

        .status-success {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        .status-error {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        .status-warning {
            background: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
            transition: transform 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
        }

        .metric-value {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .table-container {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .table-header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .table-header h3 {
            color: white !important;
            margin: 0 0 10px 0;
            font-size: 1.8em;
            text-align: center;
        }

        .table-header h4 {
            color: white !important;
            margin: 8px 0;
            font-size: 1.2em;
            text-align: center;
            font-weight: 600;
        }

        .table-scroll {
            max-height: 600px;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e1e8ed;
        }

        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        tr:hover {
            background: #f8f9ff;
        }

        .section-header {
            background: #f39c12 !important;
            color: white !important;
            font-weight: 700;
        }

        .section-header.inversion {
            background: #27ae60 !important;
        }

        .section-header.total {
            background: #e74c3c !important;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .export-btn {
            background: #27ae60;
            margin-bottom: 15px;
            width: auto;
            padding: 10px 20px;
            font-size: 14px;
        }

        .export-btn:hover {
            background: #2ecc71;
        }

        @media (max-width: 768px) {
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .tabs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè¶ Indicadores de Cartera de Cr√©dito - BDE</h1>
            <p>Sistema de An√°lisis de Cobertura de Provisiones y Calidad de Cartera</p>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab('cargar')">
                üìÅ Cargar Datos
            </div>
            <div class="tab" onclick="switchTab('indicadores')">
                üìä Indicadores 2.3.3.2 y 2.3.3.3
            </div>
        </div>

        <!-- Tab 1: Cargar Datos -->
        <div id="cargar" class="tab-content active">
            <div class="control-grid">
                <div class="card">
                    <h3>üìÅ Cargar Archivo Excel</h3>
                    <div class="form-group">
                        <label>Seleccionar archivo Excel:</label>
                        <div class="file-input-wrapper">
                            <input type="file" class="file-input" id="archivo_excel" accept=".xlsx,.xls">
                            <div class="file-input-display">
                                <div class="file-icon">üìÑ</div>
                                <div class="file-text" id="file-text">Arrastra tu archivo aqu√≠ o haz clic para seleccionar</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>üìä Tipo de An√°lisis</h3>
                    <div class="form-group">
                        <label>Seleccionar periodicidad:</label>
                        <div class="radio-group">
                            <div class="radio-option" onclick="selectRadio('mensual')">
                                <input type="radio" name="tipo_analisis" value="mensual">
                                üìÖ Mensual
                            </div>
                            <div class="radio-option selected" onclick="selectRadio('trimestral')">
                                <input type="radio" name="tipo_analisis" value="trimestral" checked>
                                üìà Trimestral
                            </div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>üìÖ Fecha de An√°lisis</h3>
                    <div class="form-group">
                        <label for="fecha_seleccionada">Fecha disponible:</label>
                        <select id="fecha_seleccionada" disabled>
                            <option>Carga un archivo primero</option>
                        </select>
                    </div>
                    <button class="btn" id="procesar_datos" onclick="procesarDatos()" disabled>
                        üîÑ Procesar An√°lisis
                    </button>
                </div>
            </div>

            <div class="card">
                <h3>üìä Estado del Sistema</h3>
                <div id="estado_carga">
                    <div class="status-box status-error">
                        <h4>üìÅ Sin datos cargados</h4>
                        <p>Selecciona un archivo Excel para comenzar el an√°lisis.</p>
                    </div>
                </div>
                
                <!-- Secci√≥n de informaci√≥n del dataset eliminada -->
            </div>
        </div>

        <!-- Tab 2: Indicadores -->
        <div id="indicadores" class="tab-content">
            <div class="card">
                <div class="table-header">
                    <h3>INDICADORES DE CARTERA DE CR√âDITO - BDE</h3>
                    <h4>2.3.3.2 COBERTURA DE PROVISIONES POR SEGMENTO</h4>
                    <h4>2.3.3.3 CALIDAD DE CARTERA POR SEGMENTOS DE CR√âDITO</h4>
                    <h4 id="fecha_indicadores">üìÖ Per√≠odo de an√°lisis: No disponible</h4>
                </div>
            </div>

            <div class="metrics-grid" id="metrics_container" style="display: none;">
                <div class="metric-card">
                    <div class="metric-value" id="total_productivo">$0M</div>
                    <div class="metric-label">Cartera Productivo</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="total_inversion">$0M</div>
                    <div class="metric-label">Cartera Inv. P√∫blica</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="cobertura_total">0%</div>
                    <div class="metric-label">Cobertura Total</div>
                </div>
            </div>

            <div class="card">
                <div id="no_data_message">
                    <div class="status-box status-error">
                        <h4>‚ö†Ô∏è Datos no disponibles</h4>
                        <p>Por favor, carga un archivo Excel y procesa los datos en la pesta√±a 'Cargar Datos'.</p>
                    </div>
                </div>

                <div id="tabla_indicadores_container" style="display: none;">
                    <button class="btn export-btn" onclick="exportarExcel()">
                        üìä Exportar a Excel
                    </button>
                    <div class="table-container">
                        <div class="table-scroll">
                            <table id="tabla_indicadores">
                                <thead></thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Procesando datos...</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        // Global variables
        let datosOriginales = null;
        let fechasDisponibles = [];
        let fechasTrimestrales = [];
        let analisisCompleto = null;

        // Tab switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
        }

        // Radio button selection
        function selectRadio(value) {
            document.querySelectorAll('.radio-option').forEach(option => option.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
            
            document.querySelectorAll('input[name="tipo_analisis"]').forEach(input => {
                input.checked = input.value === value;
            });
            
            updateFechaSelector();
        }

        // File input handling
        document.getElementById('archivo_excel').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const fileText = document.getElementById('file-text');
            
            if (file) {
                fileText.textContent = file.name;
                fileText.classList.add('has-file');
                cargarArchivo(file);
            } else {
                fileText.textContent = 'Arrastra tu archivo aqu√≠ o haz clic para seleccionar';
                fileText.classList.remove('has-file');
            }
        });

        // Generate dates function (mimicking R code)
        function generarFechas(numColumnas) {
            const fechas = [];
            let year = 2003;
            let month = 1;
            
            for (let i = 0; i < numColumnas; i++) {
                let day;
                if (month === 2) {
                    day = ((year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0)) ? 29 : 28;
                } else if ([4, 6, 9, 11].includes(month)) {
                    day = 30;
                } else {
                    day = 31;
                }
                
                const fechaStr = `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}/${year}`;
                fechas.push(fechaStr);
                
                month++;
                if (month > 12) {
                    month = 1;
                    year++;
                }
            }
            
            return fechas;
        }

        // Generate quarterly dates
        function generarFechasTrimestrales(fechasMensuales) {
            const fechasTrimestrales = [];
            const etiquetas = [];
            
            fechasMensuales.forEach(fecha => {
                const [dia, mes, a√±o] = fecha.split('/').map(Number);
                
                // Q1: Marzo (31/03), Q2: Junio (30/06), Q3: Septiembre (30/09), Q4: Diciembre (31/12)
                if (mes === 3 || mes === 6 || mes === 9 || mes === 12) {
                    const trimestre = mes === 3 ? 'Q1' : mes === 6 ? 'Q2' : mes === 9 ? 'Q3' : 'Q4';
                    fechasTrimestrales.push(fecha);
                    etiquetas.push(`${trimestre} ${a√±o} (${fecha})`);
                }
            });
            
            return { fechas: fechasTrimestrales, etiquetas };
        }

        // Funci√≥n para cargar datos desde GitHub
        async function cargarDatosIniciales() {
            try {
                showLoading(true);
                console.log('üîÑ Cargando datos iniciales desde GitHub...');
                
                // URL del archivo en GitHub (raw)
                const githubUrl = 'https://raw.githubusercontent.com/Christiti99-crypto/bde-credit-dashboard/main/BDD/BANCO%20DE%20DESARROLLO%20DEL%20ECUADOR%20B.P.%202025_06.xlsx';
                
                // Descargar archivo desde GitHub
                const response = await fetch(githubUrl);
                if (!response.ok) {
                    throw new Error(`Error al descargar archivo: ${response.status} ${response.statusText}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                
                // Procesar archivo Excel usando la misma l√≥gica
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                
                console.log('üìä Procesando datos iniciales desde GitHub...');
                console.log('Rango detectado:', worksheet['!ref']);
                
                // Leer datos desde A5 (misma l√≥gica que cargarArchivo)
                const fullData = XLSX.utils.sheet_to_json(worksheet, { 
                    header: 1,
                    defval: null,
                    range: 4
                });
                
                if (!fullData[0] || fullData[0].length < 5) {
                    throw new Error('El archivo inicial no tiene el formato esperado');
                }
                
                // Procesar datos con la misma l√≥gica
                const current_names = fullData[0];
                const numeric_columns_start = 2;
                const numeric_columns_end = current_names.length - 2;
                const numeric_columns_count = numeric_columns_end - numeric_columns_start;
                
                const fechasGeneradas = generarFechas(numeric_columns_count);
                const all_new_names = ['CODIGO', 'CUENTA', ...fechasGeneradas, 'VAR_ABSOLUTA', 'VAR_RELATIVA'];
                
                // Ajustar columnas si es necesario
                if (all_new_names.length < current_names.length) {
                    const extras_needed = current_names.length - all_new_names.length;
                    for (let i = 0; i < extras_needed; i++) {
                        all_new_names.splice(-2, 0, `EXTRA_COL_${i + 1}`);
                    }
                }
                
                // Estructurar datos
                const datosEstructurados = fullData.slice(1).map((row, index) => {
                    const objeto = {};
                    all_new_names.forEach((header, columnIndex) => {
                        if (header === 'CODIGO') {
                            objeto[header] = parseInt(row[columnIndex]) || 0;
                        } else if (header === 'CUENTA') {
                            objeto[header] = row[columnIndex] || '';
                        } else if (header.includes('/')) {
                            objeto[header] = parseFloat(row[columnIndex]) || 0;
                        } else {
                            objeto[header] = parseFloat(row[columnIndex]) || 0;
                        }
                    });
                    return objeto;
                }).filter(row => row.CODIGO > 0 && row.CUENTA);
                
                // Guardar datos iniciales
                datosOriginales = datosEstructurados;
                fechasDisponibles = fechasGeneradas;
                fechasTrimestrales = generarFechasTrimestrales(fechasGeneradas);
                
                console.log('‚úÖ Datos iniciales cargados exitosamente');
                console.log('üìä Filas:', datosEstructurados.length);
                console.log('üìÖ Per√≠odos:', fechasGeneradas.length);
                console.log('üóìÔ∏è Desde:', fechasGeneradas[0], 'hasta:', fechasGeneradas[fechasGeneradas.length - 1]);
                
                // Actualizar UI con estado inicial
                updateEstadoCargaInicial();
                updateFechaSelector();
                
                // Habilitar controles
                document.getElementById('fecha_seleccionada').disabled = false;
                document.getElementById('procesar_datos').disabled = false;
                
                // **PROCESAR AUTOM√ÅTICAMENTE CON LA √öLTIMA FECHA TRIMESTRAL DISPONIBLE**
                // Seleccionar autom√°ticamente el an√°lisis trimestral y la √∫ltima fecha trimestral
                document.querySelector('input[name="tipo_analisis"][value="trimestral"]').checked = true;
                document.querySelectorAll('.radio-option').forEach(option => option.classList.remove('selected'));
                document.querySelectorAll('.radio-option')[1].classList.add('selected'); // Segunda opci√≥n = trimestral
                
                updateFechaSelector(); // Actualizar selector con fechas trimestrales
                
                // Usar la √∫ltima fecha trimestral disponible
                const ultimaFechaTrimestral = fechasTrimestrales.fechas[fechasTrimestrales.fechas.length - 1];
                document.getElementById('fecha_seleccionada').value = ultimaFechaTrimestral;
                
                console.log('‚úÖ Configuraci√≥n autom√°tica: TRIMESTRAL');
                console.log('‚úÖ √öltima fecha trimestral seleccionada:', ultimaFechaTrimestral);
                
                await procesarDatos();
                
                // **CAMBIAR AUTOM√ÅTICAMENTE A LA PESTA√ëA DE INDICADORES**
                setTimeout(() => {
                    switchTab('indicadores');
                    // Actualizar visualmente las pesta√±as
                    document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                    document.querySelectorAll('.tab')[1].classList.add('active'); // Segunda pesta√±a (indicadores)
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    document.getElementById('indicadores').classList.add('active');
                }, 500);
                
                showNotification('‚úÖ Datos iniciales cargados desde GitHub y procesados autom√°ticamente', 'success');
                
            } catch (error) {
                console.error('‚ùå Error al cargar datos iniciales:', error);
                
                // Mostrar estado de error pero no bloquear la aplicaci√≥n
                updateEstadoCargaError();
                showNotification(`‚ö†Ô∏è No se pudieron cargar los datos iniciales desde GitHub. Puedes cargar tu propio archivo.`, 'warning');
            } finally {
                showLoading(false);
            }
        }

        // Actualizar estado de carga inicial exitosa
        function updateEstadoCargaInicial() {
            const container = document.getElementById('estado_carga');
            
            container.innerHTML = `
                <div class="status-box status-success">
                    <h4>‚úÖ Datos iniciales cargados desde GitHub</h4>
                    <p>Archivo: BANCO DE DESARROLLO DEL ECUADOR B.P. 2025_06.xlsx</p>
                    <p>Fechas disponibles: ${fechasDisponibles.length} per√≠odos</p>
                    <p>Per√≠odo: ${fechasDisponibles[0]} hasta ${fechasDisponibles[fechasDisponibles.length - 1]}</p>
                    <p><strong>üí° Tip:</strong> Puedes subir un nuevo archivo para reemplazar estos datos</p>
                </div>
            `;
            document.getElementById('info_dataset').style.display = 'block';
        }

        // Actualizar estado de error en carga inicial
        function updateEstadoCargaError() {
            const container = document.getElementById('estado_carga');
            
            container.innerHTML = `
                <div class="status-box status-warning">
                    <h4>‚ö†Ô∏è Datos iniciales no disponibles</h4>
                    <p>No se pudo acceder al archivo inicial desde GitHub.</p>
                    <p>Por favor, carga tu archivo Excel manualmente.</p>
                </div>
            `;
        }

        // Funci√≥n para leer y procesar archivo Excel real (AUTO-DETECCI√ìN)
        async function cargarArchivo(file) {
            try {
                showLoading(true);
                
                const tienesDatosIniciales = datosOriginales && datosOriginales.length > 0;
                if (tienesDatosIniciales) {
                    console.log('üîÑ REEMPLAZANDO datos iniciales con nuevo archivo...');
                } else {
                    console.log('üìÅ CARGANDO primer archivo...');
                }
                
                // Leer archivo Excel usando SheetJS
                const buffer = await file.arrayBuffer();
                const workbook = XLSX.read(buffer, { type: 'array' });
                
                // Obtener la primera hoja
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                
                console.log('=== AN√ÅLISIS AUTOM√ÅTICO DEL ARCHIVO ===');
                console.log('Rango completo detectado:', worksheet['!ref']);
                
                // PASO 1: Leer desde A5 hasta el final autom√°ticamente (como en tu R)
                // Equivalente a: datos_raw <- setDT(read_excel(archivo_path, range = "A5:..."))
                const fullData = XLSX.utils.sheet_to_json(worksheet, { 
                    header: 1,
                    defval: null,
                    range: 4 // Empezar desde fila 5 (√≠ndice 4)
                });
                
                if (!fullData[0] || fullData[0].length < 5) {
                    throw new Error('El archivo no tiene el formato esperado (m√≠nimo 5 columnas)');
                }
                
                // PASO 2: Obtener nombres de columnas (como current_names en R)
                const current_names = fullData[0];
                console.log('Total columnas detectadas autom√°ticamente:', current_names.length);
                
                // PASO 3: Extraer columnas num√©ricas (como en tu R)
                // numeric_columns <- current_names[3:(length(current_names)-2)]
                const numeric_columns_start = 2; // √çndice 2 = columna 3
                const numeric_columns_end = current_names.length - 2; // length - 2
                const numeric_columns_count = numeric_columns_end - numeric_columns_start;
                
                console.log('=== L√ìGICA DE TU C√ìDIGO R ===');
                console.log('Columnas num√©ricas: desde', numeric_columns_start + 1, 'hasta', numeric_columns_end);
                console.log('Cantidad de per√≠odos detectados:', numeric_columns_count);
                
                if (numeric_columns_count <= 0) {
                    throw new Error('No se detectaron columnas de fechas v√°lidas');
                }
                
                // PASO 4: Generar fechas autom√°ticamente
                // dates_vector <- generar_fechas(length(numeric_columns))
                const fechasGeneradas = generarFechas(numeric_columns_count);
                
                console.log('=== FECHAS GENERADAS AUTOM√ÅTICAMENTE ===');
                console.log('Total fechas:', fechasGeneradas.length);
                console.log('Primera fecha:', fechasGeneradas[0]);
                console.log('√öltima fecha:', fechasGeneradas[fechasGeneradas.length - 1]);
                console.log('A√±os cubiertos:', 
                    fechasGeneradas[0].split('/')[2], 
                    'al', 
                    fechasGeneradas[fechasGeneradas.length - 1].split('/')[2]
                );
                
                // PASO 5: Crear nombres de columnas finales
                // all_new_names <- c("C√ìDIGO", "CUENTA", dates_vector, "VAR ABSOLUTA", "VAR RELATIVA")
                const all_new_names = ['CODIGO', 'CUENTA', ...fechasGeneradas, 'VAR_ABSOLUTA', 'VAR_RELATIVA'];
                
                // Verificar que coincida el n√∫mero de columnas
                if (all_new_names.length !== current_names.length) {
                    console.warn('‚ö†Ô∏è Discrepancia en n√∫mero de columnas:');
                    console.warn('Esperadas:', all_new_names.length);
                    console.warn('Detectadas:', current_names.length);
                    
                    // Ajustar autom√°ticamente
                    if (all_new_names.length < current_names.length) {
                        // Agregar columnas extra si es necesario
                        const extras_needed = current_names.length - all_new_names.length;
                        for (let i = 0; i < extras_needed; i++) {
                            all_new_names.splice(-2, 0, `EXTRA_COL_${i + 1}`);
                        }
                    }
                }
                
                console.log('Estructura final de columnas:', all_new_names.length, 'columnas');
                
                // PASO 6: Convertir datos (equivalente a setnames en R)
                const datosEstructurados = fullData.slice(1).map((row, index) => {
                    const objeto = {};
                    all_new_names.forEach((header, columnIndex) => {
                        if (header === 'CODIGO') {
                            objeto[header] = parseInt(row[columnIndex]) || 0;
                        } else if (header === 'CUENTA') {
                            objeto[header] = row[columnIndex] || '';
                        } else if (header.includes('/')) { // Es una fecha
                            objeto[header] = parseFloat(row[columnIndex]) || 0;
                        } else { // VAR_ABSOLUTA, VAR_RELATIVA, etc.
                            objeto[header] = parseFloat(row[columnIndex]) || 0;
                        }
                    });
                    return objeto;
                }).filter(row => row.CODIGO > 0 && row.CUENTA); // Filtrar filas v√°lidas
                
                // Guardar datos procesados
                datosOriginales = datosEstructurados;
                fechasDisponibles = fechasGeneradas;
                fechasTrimestrales = generarFechasTrimestrales(fechasGeneradas);
                
                console.log('=== RESULTADO FINAL ===');
                console.log('‚úÖ Filas de datos v√°lidas:', datosEstructurados.length);
                console.log('‚úÖ Per√≠odos disponibles:', fechasGeneradas.length);
                console.log('‚úÖ Per√≠odo:', fechasGeneradas[0], 'al', fechasGeneradas[fechasGeneradas.length - 1]);
                console.log('‚úÖ Fechas trimestrales:', fechasTrimestrales.fechas.length);
                
                if (fechasTrimestrales.fechas.length > 0) {
                    console.log('‚úÖ √öltimas fechas trimestrales:', fechasTrimestrales.fechas.slice(-3));
                }
                
                // Verificar algunos c√≥digos clave para asegurar que los datos son correctos
                const codigosPrueba = [1401, 1425, 1474, 149905];
                console.log('=== VERIFICACI√ìN DE C√ìDIGOS CLAVE ===');
                codigosPrueba.forEach(codigo => {
                    const encontrado = datosEstructurados.find(row => row.CODIGO === codigo);
                    if (encontrado) {
                        console.log(`‚úÖ C√≥digo ${codigo} encontrado:`, encontrado.CUENTA);
                    } else {
                        console.warn(`‚ö†Ô∏è C√≥digo ${codigo} NO encontrado`);
                    }
                });
                
                // Actualizar UI
                updateEstadoCarga(true, file.name);
                updateFechaSelector();
                
                // Habilitar controles
                document.getElementById('fecha_seleccionada').disabled = false;
                document.getElementById('procesar_datos').disabled = false;
                
                const mensajeExito = tienesDatosIniciales ? 
                    `‚úÖ Archivo reemplazado exitosamente: ${fechasGeneradas.length} per√≠odos detectados` :
                    `‚úÖ Archivo cargado exitosamente: ${fechasGeneradas.length} per√≠odos detectados`;
                
                showNotification(mensajeExito, 'success');
                
            } catch (error) {
                console.error('Error detallado:', error);
                showNotification('‚ùå Error al procesar archivo: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Update fecha selector based on analysis type
        function updateFechaSelector() {
            const selector = document.getElementById('fecha_seleccionada');
            const tipoAnalisis = document.querySelector('input[name="tipo_analisis"]:checked').value;
            
            selector.innerHTML = '';
            
            if (tipoAnalisis === 'mensual' && fechasDisponibles.length > 0) {
                fechasDisponibles.forEach(fecha => {
                    const option = document.createElement('option');
                    option.value = fecha;
                    option.textContent = fecha;
                    selector.appendChild(option);
                });
                selector.value = fechasDisponibles[fechasDisponibles.length - 1];
            } else if (tipoAnalisis === 'trimestral' && fechasTrimestrales.fechas.length > 0) {
                fechasTrimestrales.fechas.forEach((fecha, index) => {
                    const option = document.createElement('option');
                    option.value = fecha;
                    option.textContent = fechasTrimestrales.etiquetas[index];
                    selector.appendChild(option);
                });
                // Seleccionar autom√°ticamente la √∫ltima fecha trimestral
                selector.value = fechasTrimestrales.fechas[fechasTrimestrales.fechas.length - 1];
            }
        }

        // Update estado carga
        function updateEstadoCarga(success, nombreArchivo = null) {
            const container = document.getElementById('estado_carga');
            
            if (success) {
                const esReemplazo = nombreArchivo && datosOriginales && datosOriginales.length > 0;
                const tipoOperacion = esReemplazo ? 'reemplazado' : 'cargado';
                const iconoOperacion = esReemplazo ? 'üîÑ' : '‚úÖ';
                
                container.innerHTML = `
                    <div class="status-box status-success">
                        <h4>${iconoOperacion} Archivo ${tipoOperacion} correctamente</h4>
                        ${nombreArchivo ? `<p><strong>Archivo:</strong> ${nombreArchivo}</p>` : ''}
                        <p>Fechas disponibles: ${fechasDisponibles.length} per√≠odos</p>
                        <p>Desde: ${fechasDisponibles[0]} hasta: ${fechasDisponibles[fechasDisponibles.length - 1]}</p>
                        ${esReemplazo ? '<p><strong>üìä Los indicadores se actualizar√°n con los nuevos datos</strong></p>' : ''}
                    </div>
                `;
            }
        }

        // Traducci√≥n exacta de tu funci√≥n R: procesar_cartera_productiva
        function procesar_cartera_productiva(datos, fecha_col) {
            // TOTAL CARTERA DE CREDITO PRODUCTIVO
            const codigos_total = [1401, 1409, 1417, 1425, 1433, 1441, 1449, 1457, 1465];
            const total_credito = datos
                .filter(row => codigos_total.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Total de Provisiones Espec√≠ficas - traducci√≥n exacta del R
            // res_temp <- copy(res)
            // res_temp[C√ìDIGO == 149905, (fecha_col) := get(fecha_col) * -1]
            // total_provisiones <- res_temp[C√ìDIGO %in% c(149905, 741401, 741409), sum(get(fecha_col), na.rm = TRUE)]
            
            let total_provisiones = 0;
            datos.forEach(row => {
                if (row.CODIGO === 149905) {
                    // Multiplicar por -1 como en el c√≥digo R
                    total_provisiones += (parseFloat(row[fecha_col]) || 0) * -1;
                } else if ([741401, 741409].includes(row.CODIGO)) {
                    total_provisiones += (parseFloat(row[fecha_col]) || 0);
                }
            });
            
            // Total Provisi√≥n Gen√©rica
            // provision_generica <- res[C√ìDIGO %in% c(741420, 741428, 741429), sum(get(fecha_col), na.rm = TRUE)]
            const codigos_provision_generica = [741420, 741428, 741429];
            const provision_generica = datos
                .filter(row => codigos_provision_generica.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Cartera por Vencer
            // cartera_vencer <- res[C√ìDIGO %in% c(1401, 1409, 1417, 149105, 149405), sum(get(fecha_col), na.rm = TRUE)]
            const codigos_vencer = [1401, 1409, 1417, 149105, 149405];
            const cartera_vencer = datos
                .filter(row => codigos_vencer.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Total Cartera en Riesgo
            // cartera_riesgo <- res[C√ìDIGO %in% c(1425, 1433, 1441, 1449, 1457, 1465), sum(get(fecha_col), na.rm = TRUE)]
            const codigos_riesgo = [1425, 1433, 1441, 1449, 1457, 1465];
            const cartera_riesgo = datos
                .filter(row => codigos_riesgo.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Cartera NDI
            // cartera_ndi <- res[C√ìDIGO %in% c(1425, 1433, 1441, 149205, 149505), sum(get(fecha_col), na.rm = TRUE)]
            const codigos_ndi = [1425, 1433, 1441, 149205, 149505];
            const cartera_ndi = datos
                .filter(row => codigos_ndi.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Cartera Vencida
            // cartera_vencida <- res[C√ìDIGO %in% c(1449, 1457, 1465, 149305, 149605), sum(get(fecha_col), na.rm = TRUE)]
            const codigos_vencida = [1449, 1457, 1465, 149305, 149605];
            const cartera_vencida = datos
                .filter(row => codigos_vencida.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            return {
                total_credito,
                total_provisiones,
                provision_generica,
                cartera_vencer,
                cartera_riesgo,
                cartera_ndi,
                cartera_vencida
            };
        }

        // Traducci√≥n exacta de tu funci√≥n R: procesar_cartera_inversion
        function procesar_cartera_inversion(datos, fecha_col) {
            // Total Cartera Inversi√≥n P√∫blica
            // total_credito <- res[C√ìDIGO %in% c(1474, 1476, 1478, 1480, 1482, 1484, 1486, 1488, 1490, 1491, 1492, 1493, 1494, 1495, 1496), sum(get(fecha_col), na.rm = TRUE)]
            const codigos_total = [1474, 1476, 1478, 1480, 1482, 1484, 1486, 1488, 1490, 1491, 1492, 1493, 1494, 1495, 1496];
            const total_credito = datos
                .filter(row => codigos_total.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Total Provisiones Espec√≠ficas - traducci√≥n exacta del R
            // res_temp <- copy(res)
            // res_temp[C√ìDIGO == 149960, (fecha_col) := get(fecha_col) * -1]
            // total_provisiones <- res_temp[C√ìDIGO %in% c(149960, 741433, 741437), sum(get(fecha_col), na.rm = TRUE)]
            
            let total_provisiones = 0;
            datos.forEach(row => {
                if (row.CODIGO === 149960) {
                    // Multiplicar por -1 como en el c√≥digo R
                    total_provisiones += (parseFloat(row[fecha_col]) || 0) * -1;
                } else if ([741433, 741437].includes(row.CODIGO)) {
                    total_provisiones += (parseFloat(row[fecha_col]) || 0);
                }
            });
            
            // Total Provisi√≥n Gen√©rica
            // provision_generica <- res[C√ìDIGO %in% c(741442), sum(get(fecha_col), na.rm = TRUE)]
            const provision_generica = datos
                .filter(row => row.CODIGO === 741442)
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Cartera por Vencer
            // cartera_vencer <- res[C√ìDIGO %in% c(1474, 1476, 1478, 1491, 1494), sum(get(fecha_col), na.rm = TRUE)]
            const codigos_vencer = [1474, 1476, 1478, 1491, 1494];
            const cartera_vencer = datos
                .filter(row => codigos_vencer.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Total Cartera en Riesgo
            // cartera_riesgo <- res[C√ìDIGO %in% c(1480, 1482, 1484, 1486, 1488, 1490, 149245, 149345, 149545, 149645), sum(get(fecha_col), na.rm = TRUE)]
            const codigos_riesgo = [1480, 1482, 1484, 1486, 1488, 1490, 149245, 149345, 149545, 149645];
            const cartera_riesgo = datos
                .filter(row => codigos_riesgo.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Cartera NDI
            // cartera_ndi <- res[C√ìDIGO %in% c(1480, 1482, 1484, 149545, 149245), sum(get(fecha_col), na.rm = TRUE)]
            const codigos_ndi = [1480, 1482, 1484, 149545, 149245];
            const cartera_ndi = datos
                .filter(row => codigos_ndi.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Cartera Vencida
            // cartera_vencida <- res[C√ìDIGO %in% c(1486, 1488, 1490, 149345, 149645), sum(get(fecha_col), na.rm = TRUE)]
            const codigos_vencida = [1486, 1488, 1490, 149345, 149645];
            const cartera_vencida = datos
                .filter(row => codigos_vencida.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            return {
                total_credito,
                total_provisiones,
                provision_generica,
                cartera_vencer,
                cartera_riesgo,
                cartera_ndi,
                cartera_vencida
            };
        }

        // Process data function usando las funciones R traducidas
        async function procesarDatos() {
            try {
                showLoading(true);
                
                if (!datosOriginales || !fechasDisponibles) {
                    throw new Error('No hay datos cargados');
                }
                
                const fechaSeleccionada = document.getElementById('fecha_seleccionada').value;
                const tipoAnalisis = document.querySelector('input[name="tipo_analisis"]:checked').value;
                
                console.log('=== PROCESANDO DATOS CON L√ìGICA R TRADUCIDA ===');
                console.log('Fecha seleccionada:', fechaSeleccionada);
                console.log('Tipo an√°lisis:', tipoAnalisis);
                console.log('Total filas de datos:', datosOriginales.length);
                
                // Simular procesamiento
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Usar las funciones R traducidas
                const productivo = procesar_cartera_productiva(datosOriginales, fechaSeleccionada);
                const inversion = procesar_cartera_inversion(datosOriginales, fechaSeleccionada);
                
                console.log('=== RESULTADOS CARTERA PRODUCTIVA ===');
                console.log('Total Cr√©dito:', productivo.total_credito.toLocaleString());
                console.log('Total Provisiones:', productivo.total_provisiones.toLocaleString());
                console.log('Provisi√≥n Gen√©rica:', productivo.provision_generica.toLocaleString());
                console.log('Cartera en Riesgo:', productivo.cartera_riesgo.toLocaleString());
                
                console.log('=== RESULTADOS CARTERA INVERSI√ìN P√öBLICA ===');
                console.log('Total Cr√©dito:', inversion.total_credito.toLocaleString());
                console.log('Total Provisiones:', inversion.total_provisiones.toLocaleString());
                console.log('Provisi√≥n Gen√©rica:', inversion.provision_generica.toLocaleString());
                console.log('Cartera en Riesgo:', inversion.cartera_riesgo.toLocaleString());
                
                // Calcular coberturas usando la misma f√≥rmula que en R
                const cobertura_productivo = productivo.cartera_riesgo > 0 ? 
                    ((productivo.total_provisiones + productivo.provision_generica) / productivo.cartera_riesgo) * 100 : 0;
                
                const cobertura_inversion = inversion.cartera_riesgo > 0 ? 
                    ((inversion.total_provisiones + inversion.provision_generica) / inversion.cartera_riesgo) * 100 : 0;
                
                console.log('=== COBERTURAS CALCULADAS ===');
                console.log('Cobertura Productivo:', cobertura_productivo.toFixed(2) + '%');
                console.log('Cobertura Inversi√≥n:', cobertura_inversion.toFixed(2) + '%');
                
                analisisCompleto = {
                    fecha: fechaSeleccionada,
                    tipo_analisis: tipoAnalisis,
                    productivo,
                    inversion
                };
                
                updateIndicadores();
                showNotification('‚úÖ An√°lisis procesado con l√≥gica R traducida', 'success');
                
            } catch (error) {
                console.error('Error en procesamiento:', error);
                showNotification('‚ùå Error al procesar datos: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Update indicators display
        function updateIndicadores() {
            if (!analisisCompleto) return;
            
            const { productivo, inversion, fecha, tipo_analisis } = analisisCompleto;
            
            // Update metrics
            document.getElementById('total_productivo').textContent = `${Math.round(productivo.total_credito / 1000000)}M`;
            document.getElementById('total_inversion').textContent = `${Math.round(inversion.total_credito / 1000000)}M`;
            
            const coberturaTotal = ((productivo.total_provisiones + productivo.provision_generica + 
                                  inversion.total_provisiones + inversion.provision_generica) / 
                                 (productivo.cartera_riesgo + inversion.cartera_riesgo)) * 100;
            document.getElementById('cobertura_total').textContent = `${coberturaTotal.toFixed(2)}%`;
            
            // Update date display
            const tipoTexto = tipo_analisis === 'mensual' ? 'MENSUAL' : 'TRIMESTRAL';
            document.getElementById('fecha_indicadores').textContent = `üìÖ Per√≠odo de an√°lisis: ${fecha} (${tipoTexto})`;
            
            // Show metrics and table
            document.getElementById('metrics_container').style.display = 'grid';
            document.getElementById('no_data_message').style.display = 'none';
            document.getElementById('tabla_indicadores_container').style.display = 'block';
            
            // Generate indicators table
            generateIndicatorsTable();
        }

        // Generate indicators table
        function generateIndicatorsTable() {
            if (!analisisCompleto) return;
            
            const { productivo, inversion, tipo_analisis } = analisisCompleto;
            const table = document.getElementById('tabla_indicadores');
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            // Calculate percentages and coverages
            const coberturaProductivo = ((productivo.total_provisiones + productivo.provision_generica) / productivo.cartera_riesgo) * 100;
            const coberturaInversion = ((inversion.total_provisiones + inversion.provision_generica) / inversion.cartera_riesgo) * 100;
            const coberturaTotal = ((productivo.total_provisiones + productivo.provision_generica + 
                                  inversion.total_provisiones + inversion.provision_generica) / 
                                 (productivo.cartera_riesgo + inversion.cartera_riesgo)) * 100;
            
            // Format numbers
            const formatNumber = (num) => new Intl.NumberFormat('es-ES').format(Math.round(num));
            const formatPercent = (num) => `${num.toFixed(2)}%`;
            
            const tipoTexto = tipo_analisis === 'mensual' ? 'MENSUAL' : 'TRIMESTRAL';
            
            // Table header
            thead.innerHTML = `
                <tr>
                    <th style="width: 50%;">INDICADORES</th>
                    <th style="width: 50%;">${analisisCompleto.fecha}</th>
                </tr>
            `;
            
            // Table data
            const rows = [
                {
                    label: `2.3.3.2 COBERTURA DE PROVISIONES POR SEGMENTO: TOTAL DE PROVISIONES /CARTERA EN RIESGO - AN√ÅLISIS ${tipoTexto}`,
                    value: '',
                    class: 'section-header'
                },
                {
                    label: 'CARTERA PRODUCTIVO (*)',
                    value: formatPercent(coberturaProductivo),
                    class: 'section-header'
                },
                {
                    label: 'CARTERA INVERSI√ìN P√öBLICA',
                    value: formatPercent(coberturaInversion),
                    class: 'section-header inversion'
                },
                {
                    label: 'TOTAL CARTERA DE CR√âDITO PRODUCTIVO',
                    value: formatNumber(productivo.total_credito)
                },
                {
                    label: 'TOTAL PROVISIONES ESPEC√çFICAS CARTERA PRODUCTIVO',
                    value: formatNumber(productivo.total_provisiones)
                },
                {
                    label: 'TOTAL PROVISI√ìN GEN√âRICA CARTERA PRODUCTIVO',
                    value: formatNumber(productivo.provision_generica)
                },
                {
                    label: 'CARTERA POR VENCER',
                    value: formatNumber(productivo.cartera_vencer)
                },
                {
                    label: 'TOTAL CARTERA EN RIESGO',
                    value: formatNumber(productivo.cartera_riesgo)
                },
                {
                    label: 'CARTERA QUE NO DEVENGA INTERES',
                    value: formatNumber(productivo.cartera_ndi)
                },
                {
                    label: 'CARTERA VENCIDA',
                    value: formatNumber(productivo.cartera_vencida)
                },
                {
                    label: 'TOTAL CARTERA DE CR√âDITO INVERSI√ìN P√öBLICA',
                    value: formatNumber(inversion.total_credito)
                },
                {
                    label: 'TOTAL PROVISIONES ESPEC√çFICAS CARTERA DE CR√âDITO INVERSI√ìN P√öBLICA',
                    value: formatNumber(inversion.total_provisiones)
                },
                {
                    label: 'TOTAL PROVISI√ìN GEN√âRICA CARTERA INV. P√öBLICA',
                    value: formatNumber(inversion.provision_generica)
                },
                {
                    label: 'CARTERA POR VENCER',
                    value: formatNumber(inversion.cartera_vencer)
                },
                {
                    label: 'TOTAL CARTERA EN RIESGO',
                    value: formatNumber(inversion.cartera_riesgo)
                },
                {
                    label: 'CARTERA QUE NO DEVENGA INTERES',
                    value: formatNumber(inversion.cartera_ndi)
                },
                {
                    label: 'CARTERA VENCIDA',
                    value: formatNumber(inversion.cartera_vencida)
                },
                {
                    label: 'COBERTURA TOTAL CARTERA',
                    value: formatPercent(coberturaTotal),
                    class: 'section-header total'
                },
                {
                    label: `2.3.3.3 CALIDAD DE CARTERA POR SEGMENTOS DE CR√âDITO - AN√ÅLISIS ${tipoTexto}:`,
                    value: '',
                    class: 'section-header'
                },
                {
                    label: 'CARTERA PRODUCTIVO',
                    value: '',
                    class: 'section-header'
                },
                {
                    label: 'PORCENTAJE DE CARTERA POR VENCER',
                    value: formatPercent((productivo.cartera_vencer / productivo.total_credito) * 100)
                },
                {
                    label: 'PORCENTAJE DE CARTERA EN RIESGO',
                    value: formatPercent((productivo.cartera_riesgo / productivo.total_credito) * 100)
                },
                {
                    label: 'PORCENTAJE DE CARTERA QUE NO DEVENGA INTERES',
                    value: formatPercent((productivo.cartera_ndi / productivo.total_credito) * 100)
                },
                {
                    label: 'PORCENTAJE DE CARTERA VENCIDA',
                    value: formatPercent((productivo.cartera_vencida / productivo.total_credito) * 100)
                },
                {
                    label: 'CARTERA INVERSI√ìN P√öBLICA',
                    value: '',
                    class: 'section-header inversion'
                },
                {
                    label: 'PORCENTAJE DE CARTERA POR VENCER',
                    value: formatPercent((inversion.cartera_vencer / inversion.total_credito) * 100)
                },
                {
                    label: 'PORCENTAJE DE CARTERA EN RIESGO',
                    value: formatPercent((inversion.cartera_riesgo / inversion.total_credito) * 100)
                },
                {
                    label: 'PORCENTAJE DE CARTERA QUE NO DEVENGA INTERES',
                    value: formatPercent((inversion.cartera_ndi / inversion.total_credito) * 100)
                },
                {
                    label: 'PORCENTAJE DE CARTERA VENCIDA',
                    value: formatPercent((inversion.cartera_vencida / inversion.total_credito) * 100)
                }
            ];
            
            tbody.innerHTML = rows.map(row => `
                <tr class="${row.class || ''}">
                    <td>${row.label}</td>
                    <td style="text-align: right; font-weight: ${row.class ? 'bold' : 'normal'};">${row.value}</td>
                </tr>
            `).join('');
        }

        // Export to Excel function - CORREGIDA para descargar Excel real
        function exportarExcel() {
            if (!analisisCompleto) {
                showNotification('‚ùå No hay datos para exportar', 'error');
                return;
            }
            
            try {
                const tipoTexto = analisisCompleto.tipo_analisis === 'mensual' ? 'MENSUAL' : 'TRIMESTRAL';
                const fechaSeleccionada = analisisCompleto.fecha;
                
                // Obtener las √∫ltimas 4 fechas seg√∫n el tipo de an√°lisis
                let fechasParaExportar = [];
                
                if (analisisCompleto.tipo_analisis === 'mensual') {
                    // √öltimas 4 fechas mensuales
                    const posicionFecha = fechasDisponibles.indexOf(fechaSeleccionada);
                    const inicioRango = Math.max(0, posicionFecha - 3);
                    fechasParaExportar = fechasDisponibles.slice(inicioRango, posicionFecha + 1);
                } else {
                    // √öltimas 4 fechas trimestrales
                    const posicionFecha = fechasTrimestrales.fechas.indexOf(fechaSeleccionada);
                    const inicioRango = Math.max(0, posicionFecha - 3);
                    fechasParaExportar = fechasTrimestrales.fechas.slice(inicioRango, posicionFecha + 1);
                }
                
                console.log('=== EXPORTANDO DATOS ===');
                console.log('Tipo de an√°lisis:', tipoTexto);
                console.log('Fecha principal:', fechaSeleccionada);
                console.log('Fechas para exportar:', fechasParaExportar);
                
                // Calcular datos para cada fecha
                const datosMultiplePeriodos = [];
                
                fechasParaExportar.forEach(fecha => {
                    const productivo = procesar_cartera_productiva(datosOriginales, fecha);
                    const inversion = procesar_cartera_inversion(datosOriginales, fecha);
                    
                    datosMultiplePeriodos.push({
                        fecha,
                        productivo,
                        inversion
                    });
                });
                
                // Crear estructura de datos para Excel
                const excelData = [];
                
                // T√≠tulo principal
                excelData.push([
                    `INDICADORES DE CARTERA DE CR√âDITO - BDE`,
                    '', '', '', ''
                ]);
                excelData.push([
                    `2.3.3.2 COBERTURA DE PROVISIONES POR SEGMENTO - AN√ÅLISIS ${tipoTexto}`,
                    '', '', '', ''
                ]);
                excelData.push([
                    `2.3.3.3 CALIDAD DE CARTERA POR SEGMENTOS DE CR√âDITO - AN√ÅLISIS ${tipoTexto}`,
                    '', '', '', ''
                ]);
                excelData.push([]); // L√≠nea vac√≠a
                
                // Headers con fechas
                const headers = ['INDICADORES', ...fechasParaExportar];
                excelData.push(headers);
                
                // Datos de cobertura (2.3.3.2)
                excelData.push(['COBERTURA DE PROVISIONES POR SEGMENTO:', ...Array(fechasParaExportar.length).fill('')]);
                
                // Cartera Productivo
                const coberturaProductivo = datosMultiplePeriodos.map(datos => {
                    const cobertura = datos.productivo.cartera_riesgo > 0 ? 
                        ((datos.productivo.total_provisiones + datos.productivo.provision_generica) / datos.productivo.cartera_riesgo) * 100 : 0;
                    return cobertura.toFixed(2);
                });
                excelData.push(['CARTERA PRODUCTIVO (*)', ...coberturaProductivo]);
                
                // Cartera Inversi√≥n P√∫blica
                const coberturaInversion = datosMultiplePeriodos.map(datos => {
                    const cobertura = datos.inversion.cartera_riesgo > 0 ? 
                        ((datos.inversion.total_provisiones + datos.inversion.provision_generica) / datos.inversion.cartera_riesgo) * 100 : 0;
                    return cobertura.toFixed(2);
                });
                excelData.push(['CARTERA INVERSI√ìN P√öBLICA', ...coberturaInversion]);
                
                excelData.push([]); // L√≠nea vac√≠a
                
                // Datos detallados de Cartera Productivo
                excelData.push(['CARTERA PRODUCTIVO - DETALLE:', ...Array(fechasParaExportar.length).fill('')]);
                
                const totalCreditoProductivo = datosMultiplePeriodos.map(datos => datos.productivo.total_credito);
                excelData.push(['TOTAL CARTERA DE CR√âDITO PRODUCTIVO', ...totalCreditoProductivo]);
                
                const totalProvisionesProductivo = datosMultiplePeriodos.map(datos => datos.productivo.total_provisiones);
                excelData.push(['TOTAL PROVISIONES ESPEC√çFICAS', ...totalProvisionesProductivo]);
                
                const provisionGenericaProductivo = datosMultiplePeriodos.map(datos => datos.productivo.provision_generica);
                excelData.push(['TOTAL PROVISI√ìN GEN√âRICA', ...provisionGenericaProductivo]);
                
                const carteraVencerProductivo = datosMultiplePeriodos.map(datos => datos.productivo.cartera_vencer);
                excelData.push(['CARTERA POR VENCER', ...carteraVencerProductivo]);
                
                const carteraRiesgoProductivo = datosMultiplePeriodos.map(datos => datos.productivo.cartera_riesgo);
                excelData.push(['TOTAL CARTERA EN RIESGO', ...carteraRiesgoProductivo]);
                
                const carteraNDIProductivo = datosMultiplePeriodos.map(datos => datos.productivo.cartera_ndi);
                excelData.push(['CARTERA QUE NO DEVENGA INTERES', ...carteraNDIProductivo]);
                
                const carteraVencidaProductivo = datosMultiplePeriodos.map(datos => datos.productivo.cartera_vencida);
                excelData.push(['CARTERA VENCIDA', ...carteraVencidaProductivo]);
                
                excelData.push([]); // L√≠nea vac√≠a
                
                // Datos detallados de Cartera Inversi√≥n P√∫blica
                excelData.push(['CARTERA INVERSI√ìN P√öBLICA - DETALLE:', ...Array(fechasParaExportar.length).fill('')]);
                
                const totalCreditoInversion = datosMultiplePeriodos.map(datos => datos.inversion.total_credito);
                excelData.push(['TOTAL CARTERA DE CR√âDITO INVERSI√ìN P√öBLICA', ...totalCreditoInversion]);
                
                const totalProvisionesInversion = datosMultiplePeriodos.map(datos => datos.inversion.total_provisiones);
                excelData.push(['TOTAL PROVISIONES ESPEC√çFICAS', ...totalProvisionesInversion]);
                
                const provisionGenericaInversion = datosMultiplePeriodos.map(datos => datos.inversion.provision_generica);
                excelData.push(['TOTAL PROVISI√ìN GEN√âRICA', ...provisionGenericaInversion]);
                
                const carteraVencerInversion = datosMultiplePeriodos.map(datos => datos.inversion.cartera_vencer);
                excelData.push(['CARTERA POR VENCER', ...carteraVencerInversion]);
                
                const carteraRiesgoInversion = datosMultiplePeriodos.map(datos => datos.inversion.cartera_riesgo);
                excelData.push(['TOTAL CARTERA EN RIESGO', ...carteraRiesgoInversion]);
                
                const carteraNDIInversion = datosMultiplePeriodos.map(datos => datos.inversion.cartera_ndi);
                excelData.push(['CARTERA QUE NO DEVENGA INTERES', ...carteraNDIInversion]);
                
                const carteraVencidaInversion = datosMultiplePeriodos.map(datos => datos.inversion.cartera_vencida);
                excelData.push(['CARTERA VENCIDA', ...carteraVencidaInversion]);
                
                excelData.push([]); // L√≠nea vac√≠a
                
                // Cobertura total
                const coberturaTotalData = datosMultiplePeriodos.map(datos => {
                    const cobertura = ((datos.productivo.total_provisiones + datos.productivo.provision_generica + 
                                     datos.inversion.total_provisiones + datos.inversion.provision_generica) / 
                                    (datos.productivo.cartera_riesgo + datos.inversion.cartera_riesgo)) * 100;
                    return cobertura.toFixed(2);
                });
                excelData.push(['COBERTURA TOTAL CARTERA', ...coberturaTotalData]);
                
                excelData.push([]); // L√≠nea vac√≠a
                
                // Calidad de cartera (2.3.3.3)
                excelData.push(['CALIDAD DE CARTERA POR SEGMENTOS:', ...Array(fechasParaExportar.length).fill('')]);
                excelData.push(['CARTERA PRODUCTIVO:', ...Array(fechasParaExportar.length).fill('')]);
                
                const pctVencerProductivo = datosMultiplePeriodos.map(datos => ((datos.productivo.cartera_vencer / datos.productivo.total_credito) * 100).toFixed(2));
                excelData.push(['PORCENTAJE DE CARTERA POR VENCER', ...pctVencerProductivo]);
                
                const pctRiesgoProductivo = datosMultiplePeriodos.map(datos => ((datos.productivo.cartera_riesgo / datos.productivo.total_credito) * 100).toFixed(2));
                excelData.push(['PORCENTAJE DE CARTERA EN RIESGO', ...pctRiesgoProductivo]);
                
                const pctNDIProductivo = datosMultiplePeriodos.map(datos => ((datos.productivo.cartera_ndi / datos.productivo.total_credito) * 100).toFixed(2));
                excelData.push(['PORCENTAJE DE CARTERA QUE NO DEVENGA INTERES', ...pctNDIProductivo]);
                
                const pctVencidaProductivo = datosMultiplePeriodos.map(datos => ((datos.productivo.cartera_vencida / datos.productivo.total_credito) * 100).toFixed(2));
                excelData.push(['PORCENTAJE DE CARTERA VENCIDA', ...pctVencidaProductivo]);
                
                excelData.push(['CARTERA INVERSI√ìN P√öBLICA:', ...Array(fechasParaExportar.length).fill('')]);
                
                const pctVencerInversion = datosMultiplePeriodos.map(datos => ((datos.inversion.cartera_vencer / datos.inversion.total_credito) * 100).toFixed(2));
                excelData.push(['PORCENTAJE DE CARTERA POR VENCER', ...pctVencerInversion]);
                
                const pctRiesgoInversion = datosMultiplePeriodos.map(datos => ((datos.inversion.cartera_riesgo / datos.inversion.total_credito) * 100).toFixed(2));
                excelData.push(['PORCENTAJE DE CARTERA EN RIESGO', ...pctRiesgoInversion]);
                
                const pctNDIInversion = datosMultiplePeriodos.map(datos => ((datos.inversion.cartera_ndi / datos.inversion.total_credito) * 100).toFixed(2));
                excelData.push(['PORCENTAJE DE CARTERA QUE NO DEVENGA INTERES', ...pctNDIInversion]);
                
                const pctVencidaInversion = datosMultiplePeriodos.map(datos => ((datos.inversion.cartera_vencida / datos.inversion.total_credito) * 100).toFixed(2));
                excelData.push(['PORCENTAJE DE CARTERA VENCIDA', ...pctVencidaInversion]);
                
                // Crear workbook de Excel usando m√©todo compatible con navegador
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.aoa_to_sheet(excelData);
                
                // Aplicar anchos de columna
                const colWidths = [{ wch: 50 }, ...fechasParaExportar.map(() => ({ wch: 18 }))];
                ws['!cols'] = colWidths;
                
                // Agregar hoja al workbook
                XLSX.utils.book_append_sheet(wb, ws, 'Indicadores BDE');
                
                // Generar nombre de archivo
                const fechaArchivo = fechaSeleccionada.replace(/\//g, '_');
                const filename = `Indicadores_BDE_${tipoTexto}_${fechaArchivo}_Ultimos4Periodos.xlsx`;
                
                // Generar archivo Excel binario
                const excelBuffer = XLSX.write(wb, { 
                    bookType: 'xlsx', 
                    type: 'array',
                    compression: true
                });
                
                // Crear blob y descargar usando m√©todo compatible
                const blob = new Blob([excelBuffer], { 
                    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                });
                
                // Crear enlace de descarga
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                
                // Agregar al DOM, hacer clic y remover
                document.body.appendChild(link);
                link.click();
                
                // Limpiar
                setTimeout(() => {
                    document.body.removeChild(link);
                    window.URL.revokeObjectURL(url);
                }, 100);
                
                console.log('‚úÖ Archivo Excel generado:', filename);
                showNotification(`‚úÖ Archivo Excel descargado: ${filename}`, 'success');
                
            } catch (error) {
                console.error('Error en exportaci√≥n:', error);
                showNotification('‚ùå Error al exportar a Excel: ' + error.message, 'error');
            }
        }

        // Utility functions
        function showLoading(show) {
            document.getElementById('loading').classList.toggle('show', show);
        }

        function showNotification(message, type) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `status-box status-${type}`;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 1000;
                min-width: 300px;
                max-width: 500px;
                animation: slideIn 0.3s ease;
            `;
            notification.innerHTML = `<p>${message}</p>`;
            
            // Add animation styles
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes slideOut {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(100%); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            // Auto-remove after 4 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 4000);
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üè¶ BDE Credit Portfolio Indicators Dashboard loaded successfully');
            
            // **CARGAR DATOS INICIALES AUTOM√ÅTICAMENTE AL INICIAR**
            cargarDatosIniciales();
            
            // Add drag and drop functionality
            const fileInputDisplay = document.querySelector('.file-input-display');
            
            fileInputDisplay.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.style.borderColor = '#764ba2';
                this.style.background = '#f0f4ff';
            });
            
            fileInputDisplay.addEventListener('dragleave', function(e) {
                e.preventDefault();
                this.style.borderColor = '#667eea';
                this.style.background = '#f8f9ff';
            });
            
            fileInputDisplay.addEventListener('drop', function(e) {
                e.preventDefault();
                this.style.borderColor = '#667eea';
                this.style.background = '#f8f9ff';
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const fileInput = document.getElementById('archivo_excel');
                    fileInput.files = files;
                    
                    // Trigger change event
                    const event = new Event('change', { bubbles: true });
                    fileInput.dispatchEvent(event);
                }
            });
            
            // Add smooth scrolling to table
            const tableScroll = document.querySelector('.table-scroll');
            if (tableScroll) {
                tableScroll.style.scrollBehavior = 'smooth';
            }
        });
    </script>
</body>
</html>
