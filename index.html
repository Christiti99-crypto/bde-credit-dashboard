<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indicadores de Cartera de Cr√©dito - BDE</title>
    
    <!-- Cargar XLSX PRIMERO antes que todo -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <style>
        /* Estilos existentes... (mantener todos los estilos actuales) */
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè¶ Indicadores de Cartera de Cr√©dito - BDE</h1>
            <p>Sistema de An√°lisis de Cobertura de Provisiones y Calidad de Cartera</p>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab('cargar')">
                üìÅ Cargar Datos
            </div>
            <div class="tab" onclick="switchTab('indicadores')">
                üìä Indicadores 2.3.3.2 y 2.3.3.3
            </div>
        </div>

        <!-- Tab 1: Cargar Datos -->
        <div id="cargar" class="tab-content active">
            <div class="control-grid">
                <div class="card">
                    <h3>üìÅ Cargar Archivo Excel</h3>
                    <div class="form-group">
                        <label>Seleccionar archivo Excel:</label>
                        <div class="file-input-wrapper">
                            <input type="file" class="file-input" id="archivo_excel" accept=".xlsx,.xls">
                            <div class="file-input-display">
                                <div class="file-icon">üìÑ</div>
                                <div class="file-text" id="file-text">Arrastra tu archivo aqu√≠ o haz clic para seleccionar</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>üìä Tipo de An√°lisis</h3>
                    <div class="form-group">
                        <label>Seleccionar periodicidad:</label>
                        <div class="radio-group">
                            <div class="radio-option" onclick="selectRadio('mensual')">
                                <input type="radio" name="tipo_analisis" value="mensual">
                                üìÖ Mensual
                            </div>
                            <div class="radio-option selected" onclick="selectRadio('trimestral')">
                                <input type="radio" name="tipo_analisis" value="trimestral" checked>
                                üìà Trimestral
                            </div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>üìÖ Fecha de An√°lisis</h3>
                    <div class="form-group">
                        <label for="fecha_seleccionada">Fecha disponible:</label>
                        <select id="fecha_seleccionada" disabled>
                            <option>Carga un archivo primero</option>
                        </select>
                    </div>
                    <button class="btn" id="procesar_datos" onclick="procesarDatos()" disabled>
                        üîÑ Procesar An√°lisis
                    </button>
                </div>
            </div>

            <div class="card">
                <h3>üìä Estado del Sistema</h3>
                <div id="estado_carga">
                    <div class="status-box status-error">
                        <h4>üìÅ Sin datos cargados</h4>
                        <p>Selecciona un archivo Excel para comenzar el an√°lisis.</p>
                    </div>
                </div>
                
                <div id="info_dataset" style="display: none;">
                    <h4>üìä Informaci√≥n del Dataset:</h4>
                    <div id="dataset_info"></div>
                    
                    <h4>üìã Vista Previa de Datos:</h4>
                    <div class="table-container">
                        <div class="table-scroll">
                            <table id="preview_table">
                                <thead></thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab 2: Indicadores -->
        <div id="indicadores" class="tab-content">
            <div class="card">
                <div class="table-header">
                    <h3>INDICADORES DE CARTERA DE CR√âDITO - BDE</h3>
                    <h4>2.3.3.2 COBERTURA DE PROVISIONES POR SEGMENTO</h4>
                    <h4>2.3.3.3 CALIDAD DE CARTERA POR SEGMENTOS DE CR√âDITO</h4>
                    <h4 id="fecha_indicadores">üìÖ Per√≠odo de an√°lisis: No disponible</h4>
                </div>
            </div>

            <div class="metrics-grid" id="metrics_container" style="display: none;">
                <div class="metric-card">
                    <div class="metric-value" id="total_productivo">$0M</div>
                    <div class="metric-label">Cartera Productivo</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="total_inversion">$0M</div>
                    <div class="metric-label">Cartera Inv. P√∫blica</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="cobertura_total">0%</div>
                    <div class="metric-label">Cobertura Total</div>
                </div>
            </div>

            <div class="card">
                <div id="no_data_message">
                    <div class="status-box status-error">
                        <h4>‚ö†Ô∏è Datos no disponibles</h4>
                        <p>Por favor, carga un archivo Excel y procesa los datos en la pesta√±a 'Cargar Datos'.</p>
                    </div>
                </div>

                <div id="tabla_indicadores_container" style="display: none;">
                    <button class="btn export-btn" onclick="exportarExcel()">
                        üìä Exportar a Excel
                    </button>
                    <div class="table-container">
                        <div class="table-scroll">
                            <table id="tabla_indicadores">
                                <thead></thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Procesando datos...</p>
        </div>
    </div>

    <script>
        // Global variables
        let datosOriginales = null;
        let datosIndicCartera = null; // Nueva variable para almacenar datos de INDIC CARTERA
        let fechasDisponibles = [];
        let fechasTrimestrales = [];
        let analisisCompleto = null;

        // Tab switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
        }

        // Radio button selection
        function selectRadio(value) {
            document.querySelectorAll('.radio-option').forEach(option => option.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
            
            document.querySelectorAll('input[name="tipo_analisis"]').forEach(input => {
                input.checked = input.value === value;
            });
            
            updateFechaSelector();
        }

        // File input handling
        document.getElementById('archivo_excel').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const fileText = document.getElementById('file-text');
            
            if (file) {
                fileText.textContent = file.name;
                fileText.classList.add('has-file');
                cargarArchivo(file);
            } else {
                fileText.textContent = 'Arrastra tu archivo aqu√≠ o haz clic para seleccionar';
                fileText.classList.remove('has-file');
            }
        });

        // Generate dates function (mimicking R code)
        function generarFechas(numColumnas) {
            const fechas = [];
            let year = 2003;
            let month = 1;
            
            for (let i = 0; i < numColumnas; i++) {
                let day;
                if (month === 2) {
                    day = ((year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0)) ? 29 : 28;
                } else if ([4, 6, 9, 11].includes(month)) {
                    day = 30;
                } else {
                    day = 31;
                }
                
                const fechaStr = `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}/${year}`;
                fechas.push(fechaStr);
                
                month++;
                if (month > 12) {
                    month = 1;
                    year++;
                }
            }
            
            return fechas;
        }

        // Generate quarterly dates
        function generarFechasTrimestrales(fechasMensuales) {
            const fechasTrimestrales = [];
            const etiquetas = [];
            
            fechasMensuales.forEach(fecha => {
                const [dia, mes, a√±o] = fecha.split('/').map(Number);
                
                // Q1: Marzo (31/03), Q2: Junio (30/06), Q3: Septiembre (30/09), Q4: Diciembre (31/12)
                if (mes === 3 || mes === 6 || mes === 9 || mes === 12) {
                    const trimestre = mes === 3 ? 'Q1' : mes === 6 ? 'Q2' : mes === 9 ? 'Q3' : 'Q4';
                    fechasTrimestrales.push(fecha);
                    etiquetas.push(`${trimestre} ${a√±o} (${fecha})`);
                }
            });
            
            return { fechas: fechasTrimestrales, etiquetas };
        }

        // Funci√≥n para cargar datos desde GitHub
        async function cargarDatosIniciales() {
            try {
                showLoading(true);
                console.log('üîÑ Cargando datos iniciales desde GitHub...');
                
                // URL del archivo en GitHub (raw)
                const githubUrl = 'https://raw.githubusercontent.com/Christiti99-crypto/bde-credit-dashboard/main/BDD/BANCO%20DE%20DESARROLLO%20DEL%20ECUADOR%20B.P.%202025_06.xlsx';
                
                // Descargar archivo desde GitHub
                const response = await fetch(githubUrl);
                if (!response.ok) {
                    throw new Error(`Error al descargar archivo: ${response.status} ${response.statusText}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                
                // Procesar ambas hojas del archivo Excel
                await procesarArchivoCompleto(arrayBuffer);
                
                console.log('‚úÖ Datos iniciales cargados exitosamente');
                
                // Actualizar UI con estado inicial
                updateEstadoCargaInicial();
                updateFechaSelector();
                updateDatasetInfo(fechasDisponibles.length);
                
                // Habilitar controles
                document.getElementById('fecha_seleccionada').disabled = false;
                document.getElementById('procesar_datos').disabled = false;
                
                // **PROCESAR AUTOM√ÅTICAMENTE CON LA √öLTIMA FECHA TRIMESTRAL DISPONIBLE**
                document.querySelector('input[name="tipo_analisis"][value="trimestral"]').checked = true;
                document.querySelectorAll('.radio-option').forEach(option => option.classList.remove('selected'));
                document.querySelectorAll('.radio-option')[1].classList.add('selected');
                
                updateFechaSelector();
                
                const ultimaFechaTrimestral = fechasTrimestrales.fechas[fechasTrimestrales.fechas.length - 1];
                document.getElementById('fecha_seleccionada').value = ultimaFechaTrimestral;
                
                console.log('‚úÖ Configuraci√≥n autom√°tica: TRIMESTRAL');
                console.log('‚úÖ √öltima fecha trimestral seleccionada:', ultimaFechaTrimestral);
                
                await procesarDatos();
                
                // **CAMBIAR AUTOM√ÅTICAMENTE A LA PESTA√ëA DE INDICADORES**
                setTimeout(() => {
                    switchTab('indicadores');
                    document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                    document.querySelectorAll('.tab')[1].classList.add('active');
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    document.getElementById('indicadores').classList.add('active');
                }, 500);
                
                showNotification('‚úÖ Datos iniciales cargados desde GitHub y procesados autom√°ticamente', 'success');
                
            } catch (error) {
                console.error('‚ùå Error al cargar datos iniciales:', error);
                updateEstadoCargaError();
                showNotification(`‚ö†Ô∏è No se pudieron cargar los datos iniciales desde GitHub. Puedes cargar tu propio archivo.`, 'warning');
            } finally {
                showLoading(false);
            }
        }

        // Funci√≥n para procesar ambas hojas del archivo Excel
        async function procesarArchivoCompleto(arrayBuffer) {
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            
            // Procesar primera hoja (INDIC CARTERA)
            const sheetName1 = workbook.SheetNames.find(name => name.includes("INDIC CARTERA")) || workbook.SheetNames[0];
            const worksheet1 = workbook.Sheets[sheetName1];
            
            console.log('üìä Procesando hoja INDIC CARTERA...');
            const datosIndicCarteraRaw = XLSX.utils.sheet_to_json(worksheet1, { 
                header: 1,
                defval: null,
                range: 4 // Empezar desde fila 5 (√≠ndice 4)
            });
            
            // Procesar estructura de INDIC CARTERA (ITEM, F√ìRMULA, VARIABLES)
            if (datosIndicCarteraRaw[0] && datosIndicCarteraRaw[0].length >= 3) {
                const current_names_indic = datosIndicCarteraRaw[0];
                const numeric_columns_count_indic = current_names_indic.length - 3; // Excluir ITEM, F√ìRMULA, VARIABLES
                
                const fechasGeneradasIndic = generarFechas(numeric_columns_count_indic);
                const all_new_names_indic = ['ITEM', 'F√ìRMULA', 'VARIABLES', ...fechasGeneradasIndic];
                
                datosIndicCartera = datosIndicCarteraRaw.slice(1).map((row, index) => {
                    const objeto = {};
                    all_new_names_indic.forEach((header, columnIndex) => {
                        if (header === 'ITEM') {
                            objeto[header] = row[columnIndex] || '';
                        } else if (header === 'F√ìRMULA') {
                            objeto[header] = row[columnIndex] || '';
                        } else if (header === 'VARIABLES') {
                            objeto[header] = row[columnIndex] || '';
                        } else if (header.includes('/')) {
                            objeto[header] = parseFloat(row[columnIndex]) || 0;
                        }
                    });
                    return objeto;
                }).filter(row => row.ITEM && row.ITEM !== '');
                
                console.log('‚úÖ Datos INDIC CARTERA procesados:', datosIndicCartera.length, 'filas');
            }
            
            // Procesar segunda hoja (principal)
            const sheetName2 = workbook.SheetNames.find(name => !name.includes("INDIC CARTERA")) || workbook.SheetNames[1] || workbook.SheetNames[0];
            const worksheet2 = workbook.Sheets[sheetName2];
            
            console.log('üìä Procesando hoja principal...');
            const fullData = XLSX.utils.sheet_to_json(worksheet2, { 
                header: 1,
                defval: null,
                range: 4 // Empezar desde fila 5 (√≠ndice 4)
            });
            
            if (!fullData[0] || fullData[0].length < 5) {
                throw new Error('El archivo no tiene el formato esperado (m√≠nimo 5 columnas)');
            }
            
            const current_names = fullData[0];
            const numeric_columns_start = 2;
            const numeric_columns_end = current_names.length - 2;
            const numeric_columns_count = numeric_columns_end - numeric_columns_start;
            
            const fechasGeneradas = generarFechas(numeric_columns_count);
            const all_new_names = ['CODIGO', 'CUENTA', ...fechasGeneradas, 'VAR_ABSOLUTA', 'VAR_RELATIVA'];
            
            if (all_new_names.length !== current_names.length) {
                const extras_needed = current_names.length - all_new_names.length;
                for (let i = 0; i < extras_needed; i++) {
                    all_new_names.splice(-2, 0, `EXTRA_COL_${i + 1}`);
                }
            }
            
            datosOriginales = fullData.slice(1).map((row, index) => {
                const objeto = {};
                all_new_names.forEach((header, columnIndex) => {
                    if (header === 'CODIGO') {
                        objeto[header] = parseInt(row[columnIndex]) || 0;
                    } else if (header === 'CUENTA') {
                        objeto[header] = row[columnIndex] || '';
                    } else if (header.includes('/')) {
                        objeto[header] = parseFloat(row[columnIndex]) || 0;
                    } else {
                        objeto[header] = parseFloat(row[columnIndex]) || 0;
                    }
                });
                return objeto;
            }).filter(row => row.CODIGO > 0 && row.CUENTA);
            
            fechasDisponibles = fechasGeneradas;
            fechasTrimestrales = generarFechasTrimestrales(fechasGeneradas);
            
            console.log('‚úÖ Datos principales procesados:', datosOriginales.length, 'filas');
            console.log('‚úÖ Per√≠odos disponibles:', fechasGeneradas.length);
        }

        // Funci√≥n para leer y procesar archivo Excel real
        async function cargarArchivo(file) {
            try {
                showLoading(true);
                
                const tienesDatosIniciales = datosOriginales && datosOriginales.length > 0;
                
                const buffer = await file.arrayBuffer();
                await procesarArchivoCompleto(buffer);
                
                updateEstadoCarga(true, file.name);
                updateFechaSelector();
                updateDatasetInfo(fechasDisponibles.length);
                
                document.getElementById('fecha_seleccionada').disabled = false;
                document.getElementById('procesar_datos').disabled = false;
                
                const mensajeExito = tienesDatosIniciales ? 
                    `‚úÖ Archivo reemplazado exitosamente: ${fechasDisponibles.length} per√≠odos detectados` :
                    `‚úÖ Archivo cargado exitosamente: ${fechasDisponibles.length} per√≠odos detectados`;
                
                showNotification(mensajeExito, 'success');
                
            } catch (error) {
                console.error('Error detallado:', error);
                showNotification('‚ùå Error al procesar archivo: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Resto de funciones auxiliares (updateFechaSelector, updateEstadoCarga, updateDatasetInfo, etc.)
        // ... (mantener todas estas funciones igual)

        // Traducci√≥n exacta de tu funci√≥n R: procesar_cartera_productiva
        function procesar_cartera_productiva(datos, fecha_col) {
            // TOTAL CARTERA DE CREDITO PRODUCTIVO
            const codigos_total = [1401, 1409, 1417, 1425, 1433, 1441, 1449, 1457, 1465];
            const total_credito = datos
                .filter(row => codigos_total.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Total de Provisiones Espec√≠ficas - traducci√≥n exacta del R
            let total_provisiones = 0;
            datos.forEach(row => {
                if (row.CODIGO === 149905) {
                    total_provisiones += (parseFloat(row[fecha_col]) || 0) * -1;
                } else if ([741401, 741409].includes(row.CODIGO)) {
                    total_provisiones += (parseFloat(row[fecha_col]) || 0);
                }
            });
            
            // Total Provisi√≥n Gen√©rica
            const codigos_provision_generica = [741420, 741428, 741429];
            const provision_generica = datos
                .filter(row => codigos_provision_generica.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Cartera por Vencer
            const codigos_vencer = [1401, 1409, 1417, 149105, 149405];
            const cartera_vencer = datos
                .filter(row => codigos_vencer.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Total Cartera en Riesgo
            const codigos_riesgo = [1425, 1433, 1441, 1449, 1457, 1465];
            const cartera_riesgo = datos
                .filter(row => codigos_riesgo.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Cartera NDI
            const codigos_ndi = [1425, 1433, 1441, 149205, 149505];
            const cartera_ndi = datos
                .filter(row => codigos_ndi.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Cartera Vencida
            const codigos_vencida = [1449, 1457, 1465, 149305, 149605];
            const cartera_vencida = datos
                .filter(row => codigos_vencida.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            return {
                total_credito,
                total_provisiones,
                provision_generica,
                cartera_vencer,
                cartera_riesgo,
                cartera_ndi,
                cartera_vencida
            };
        }

        // Traducci√≥n exacta de tu funci√≥n R: procesar_cartera_inversion
        function procesar_cartera_inversion(datos, fecha_col) {
            // Total Cartera Inversi√≥n P√∫blica
            const codigos_total = [1474, 1476, 1478, 1480, 1482, 1484, 1486, 1488, 1490, 1491, 1492, 1493, 1494, 1495, 1496];
            const total_credito = datos
                .filter(row => codigos_total.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Total Provisiones Espec√≠ficas - traducci√≥n exacta del R
            let total_provisiones = 0;
            datos.forEach(row => {
                if (row.CODIGO === 149960) {
                    total_provisiones += (parseFloat(row[fecha_col]) || 0) * -1;
                } else if ([741433, 741437].includes(row.CODIGO)) {
                    total_provisiones += (parseFloat(row[fecha_col]) || 0);
                }
            });
            
            // Total Provisi√≥n Gen√©rica
            const provision_generica = datos
                .filter(row => row.CODIGO === 741442)
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Cartera por Vencer
            const codigos_vencer = [1474, 1476, 1478, 1491, 1494];
            const cartera_vencer = datos
                .filter(row => codigos_vencer.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Total Cartera en Riesgo
            const codigos_riesgo = [1480, 1482, 1484, 1486, 1488, 1490, 149245, 149345, 149545, 149645];
            const cartera_riesgo = datos
                .filter(row => codigos_riesgo.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Cartera NDI
            const codigos_ndi = [1480, 1482, 1484, 149545, 149245];
            const cartera_ndi = datos
                .filter(row => codigos_ndi.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            // Cartera Vencida
            const codigos_vencida = [1486, 1488, 1490, 149345, 149645];
            const cartera_vencida = datos
                .filter(row => codigos_vencida.includes(row.CODIGO))
                .reduce((sum, row) => sum + (parseFloat(row[fecha_col]) || 0), 0);
            
            return {
                total_credito,
                total_provisiones,
                provision_generica,
                cartera_vencer,
                cartera_riesgo,
                cartera_ndi,
                cartera_vencida
            };
        }

        // Funci√≥n para obtener el valor de la pesta√±a INDIC CARTERA seg√∫n el ITEM
        function obtener_valor_indic_cartera(item_buscado, fecha_col) {
            if (!datosIndicCartera) return 0;
            
            const fila = datosIndicCartera.find(row => row.ITEM === item_buscado);
            return fila ? (parseFloat(fila[fecha_col]) || 0) : 0;
        }

        // Process data function usando las funciones R traducidas
        async function procesarDatos() {
            try {
                showLoading(true);
                
                if (!datosOriginales || !fechasDisponibles) {
                    throw new Error('No hay datos cargados');
                }
                
                const fechaSeleccionada = document.getElementById('fecha_seleccionada').value;
                const tipoAnalisis = document.querySelector('input[name="tipo_analisis"]:checked').value;
                
                console.log('=== PROCESANDO DATOS CON L√ìGICA R TRADUCIDA ===');
                console.log('Fecha seleccionada:', fechaSeleccionada);
                console.log('Tipo an√°lisis:', tipoAnalisis);
                console.log('Total filas de datos:', datosOriginales.length);
                
                // Simular procesamiento
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Usar las funciones R traducidas
                const productivo = procesar_cartera_productiva(datosOriginales, fechaSeleccionada);
                const inversion = procesar_cartera_inversion(datosOriginales, fechaSeleccionada);
                
                console.log('=== RESULTADOS CARTERA PRODUCTIVA ===');
                console.log('Total Cr√©dito:', productivo.total_credito.toLocaleString());
                console.log('Total Provisiones:', productivo.total_provisiones.toLocaleString());
                console.log('Provisi√≥n Gen√©rica:', productivo.provision_generica.toLocaleString());
                console.log('Cartera en Riesgo:', productivo.cartera_riesgo.toLocaleString());
                
                console.log('=== RESULTADOS CARTERA INVERSI√ìN P√öBLICA ===');
                console.log('Total Cr√©dito:', inversion.total_credito.toLocaleString());
                console.log('Total Provisiones:', inversion.total_provisiones.toLocaleString());
                console.log('Provisi√≥n Gen√©rica:', inversion.provision_generica.toLocaleString());
                console.log('Cartera en Riesgo:', inversion.cartera_riesgo.toLocaleString());
                
                // Calcular coberturas usando la misma f√≥rmula que en R
                const cobertura_productivo = productivo.cartera_riesgo > 0 ? 
                    ((productivo.total_provisiones + productivo.provision_generica) / productivo.cartera_riesgo) * 100 : 0;
                
                const cobertura_inversion = inversion.cartera_riesgo > 0 ? 
                    ((inversion.total_provisiones + inversion.provision_generica) / inversion.cartera_riesgo) * 100 : 0;
                
                // Obtener datos de la pesta√±a INDIC CARTERA para el c√°lculo final
                const provisiones_incobrables = obtener_valor_indic_cartera("1499", fechaSeleccionada);
                const total_cartera_improductiva = obtener_valor_indic_cartera("(aw)", fechaSeleccionada);
                
                const cobertura_total_cartera = total_cartera_improductiva !== 0 ? 
                    (provisiones_incobrables / total_cartera_improductiva) * -100 : 0;
                
                console.log('=== COBERTURAS CALCULADAS ===');
                console.log('Cobertura Productivo:', cobertura_productivo.toFixed(2) + '%');
                console.log('Cobertura Inversi√≥n:', cobertura_inversion.toFixed(2) + '%');
                console.log('Cobertura Total Cartera:', cobertura_total_cartera.toFixed(2) + '%');
                console.log('Provisiones Incobrables:', provisiones_incobrables);
                console.log('Total Cartera Improductiva:', total_cartera_improductiva);
                
                analisisCompleto = {
                    fecha: fechaSeleccionada,
                    tipo_analisis: tipoAnalisis,
                    productivo,
                    inversion,
                    cobertura_total_cartera,
                    provisiones_incobrables,
                    total_cartera_improductiva
                };
                
                updateIndicadores();
                showNotification('‚úÖ An√°lisis procesado con l√≥gica R traducida', 'success');
                
            } catch (error) {
                console.error('Error en procesamiento:', error);
                showNotification('‚ùå Error al procesar datos: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Update indicators display
        function updateIndicadores() {
            if (!analisisCompleto) return;
            
            const { productivo, inversion, fecha, tipo_analisis, cobertura_total_cartera } = analisisCompleto;
            
            // Update metrics
            document.getElementById('total_productivo').textContent = `${Math.round(productivo.total_credito / 1000000)}M`;
            document.getElementById('total_inversion').textContent = `${Math.round(inversion.total_credito / 1000000)}M`;
            document.getElementById('cobertura_total').textContent = `${cobertura_total_cartera.toFixed(2)}%`;
            
            // Update date display
            const tipoTexto = tipo_analisis === 'mensual' ? 'MENSUAL' : 'TRIMESTRAL';
            document.getElementById('fecha_indicadores').textContent = `üìÖ Per√≠odo de an√°lisis: ${fecha} (${tipoTexto})`;
            
            // Show metrics and table
            document.getElementById('metrics_container').style.display = 'grid';
            document.getElementById('no_data_message').style.display = 'none';
            document.getElementById('tabla_indicadores_container').style.display = 'block';
            
            // Generate indicators table
            generateIndicatorsTable();
        }

        // Generate indicators table
        function generateIndicatorsTable() {
            if (!analisisCompleto) return;
            
            const { productivo, inversion, tipo_analisis, cobertura_total_cartera, provisiones_incobrables, total_cartera_improductiva } = analisisCompleto;
            const table = document.getElementById('tabla_indicadores');
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            
            // Calculate percentages and coverages
            const coberturaProductivo = ((productivo.total_provisiones + productivo.provision_generica) / productivo.cartera_riesgo) * 100;
            const coberturaInversion = ((inversion.total_provisiones + inversion.provision_generica) / inversion.cartera_riesgo) * 100;
            
            // Format numbers
            const formatNumber = (num) => new Intl.NumberFormat('es-ES').format(Math.round(num));
            const formatPercent = (num) => `${num.toFixed(2)}%`;
            
            const tipoTexto = tipo_analisis === 'mensual' ? 'MENSUAL' : 'TRIMESTRAL';
            
            // Table header
            thead.innerHTML = `
                <tr>
                    <th style="width: 50%;">INDICADORES</th>
                    <th style="width: 50%;">${analisisCompleto.fecha}</th>
                </tr>
            `;
            
            // Table data
            const rows = [
                {
                    label: `2.3.3.2 COBERTURA DE PROVISIONES POR SEGMENTO: TOTAL DE PROVISIONES /CARTERA EN RIESGO - AN√ÅLISIS ${tipoTexto}`,
                    value: '',
                    class: 'section-header'
                },
                {
                    label: 'CARTERA PRODUCTIVO (*)',
                    value: formatPercent(coberturaProductivo),
                    class: 'section-header'
                },
                {
                    label: 'CARTERA INVERSI√ìN P√öBLICA',
                    value: formatPercent(coberturaInversion),
                    class: 'section-header inversion'
                },
                {
                    label: 'TOTAL CARTERA DE CR√âDITO PRODUCTIVO',
                    value: formatNumber(productivo.total_credito)
                },
                {
                    label: 'TOTAL PROVISIONES ESPEC√çFICAS CARTERA PRODUCTIVO',
                    value: formatNumber(productivo.total_provisiones)
                },
                {
                    label: 'TOTAL PROVISI√ìN GEN√âRICA CARTERA PRODUCTIVO',
                    value: formatNumber(productivo.provision_generica)
                },
                {
                    label: 'CARTERA POR VENCER',
                    value: formatNumber(productivo.cartera_vencer)
                },
                {
                    label: 'TOTAL CARTERA EN RIESGO',
                    value: formatNumber(productivo.cartera_riesgo)
                },
                {
                    label: 'CARTERA QUE NO DEVENGA INTERES',
                    value: formatNumber(productivo.cartera_ndi)
                },
                {
                    label: 'CARTERA VENCIDA',
                    value: formatNumber(productivo.cartera_vencida)
                },
                {
                    label: 'TOTAL CARTERA DE CR√âDITO INVERSI√ìN P√öBLICA',
                    value: formatNumber(inversion.total_credito)
                },
                {
                    label: 'TOTAL PROVISIONES ESPEC√çFICAS CARTERA DE CR√âDITO INVERSI√ìN P√öBLICA',
                    value: formatNumber(inversion.total_provisiones)
                },
                {
                    label: 'TOTAL PROVISI√ìN GEN√âRICA CARTERA INV. P√öBLICA',
                    value: formatNumber(inversion.provision_generica)
                },
                {
                    label: 'CARTERA POR VENCER',
                    value: formatNumber(inversion.cartera_vencer)
                },
                {
                    label: 'TOTAL CARTERA EN RIESGO',
                    value: formatNumber(inversion.cartera_riesgo)
                },
                {
                    label: 'CARTERA QUE NO DEVENGA INTERES',
                    value: formatNumber(inversion.cartera_ndi)
                },
                {
                    label: 'CARTERA VENCIDA',
                    value: formatNumber(inversion.cartera_vencida)
                },
                {
                    label: 'PROVISIONES PARA CR√âDITOS INCOBRABLES (1499)',
                    value: formatNumber(provisiones_incobrables)
                },
                {
                    label: 'TOTAL CARTERA IMPRODUCTIVA ((aw))',
                    value: formatNumber(total_cartera_improductiva)
                },
                {
                    label: 'COBERTURA TOTAL CARTERA',
                    value: formatPercent(cobertura_total_cartera),
                    class: 'section-header total'
                },
                {
                    label: `2.3.3.3 CALIDAD DE CARTERA POR SEGMENTOS DE CR√âDITO - AN√ÅLISIS ${tipoTexto}:`,
                    value: '',
                    class: 'section-header'
                },
                {
                    label: 'CARTERA PRODUCTIVO',
                    value: '',
                    class: 'section-header'
                },
                {
                    label: 'PORCENTAJE DE CARTERA POR VENCER',
                    value: formatPercent((productivo.cartera_vencer / productivo.total_credito) * 100)
                },
                {
                    label: 'PORCENTAJE DE CARTERA EN RIESGO',
                    value: formatPercent((productivo.cartera_riesgo / productivo.total_credito) * 100)
                },
                {
                    label: 'PORCENTAJE DE CARTERA QUE NO DEVENGA INTERES',
                    value: formatPercent((productivo.cartera_ndi / productivo.total_credito) * 100)
                },
                {
                    label: 'PORCENTAJE DE CARTERA VENCIDA',
                    value: formatPercent((productivo.cartera_vencida / productivo.total_credito) * 100)
                },
                {
                    label: 'CARTERA INVERSI√ìN P√öBLICA',
                    value: '',
                    class: 'section-header inversion'
                },
                {
                    label: 'PORCENTAJE DE CARTERA POR VENCER',
                    value: formatPercent((inversion.cartera_vencer / inversion.total_credito) * 100)
                },
                {
                    label: 'PORCENTAJE DE CARTERA EN RIESGO',
                    value: formatPercent((inversion.cartera_riesgo / inversion.total_credito) * 100)
                },
                {
                    label: 'PORCENTAJE DE CARTERA QUE NO DEVENGA INTERES',
                    value: formatPercent((inversion.cartera_ndi / inversion.total_credito) * 100)
                },
                {
                    label: 'PORCENTAJE DE CARTERA VENCIDA',
                    value: formatPercent((inversion.cartera_vencida / inversion.total_credito) * 100)
                }
            ];
            
            tbody.innerHTML = rows.map(row => `
                <tr class="${row.class || ''}">
                    <td>${row.label}</td>
                    <td style="text-align: right; font-weight: ${row.class ? 'bold' : 'normal'};">${row.value}</td>
                </tr>
            `).join('');
        }

        // Resto de funciones (exportarExcel, showLoading, showNotification, etc.)
        // ... (mantener todas estas funciones igual)

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üè¶ BDE Credit Portfolio Indicators Dashboard loaded successfully');
            
            // **CARGAR DATOS INICIALES AUTOM√ÅTICAMENTE AL INICIAR**
            cargarDatosIniciales();
            
            // Add drag and drop functionality
            const fileInputDisplay = document.querySelector('.file-input-display');
            
            fileInputDisplay.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.style.borderColor = '#764ba2';
                this.style.background = '#f0f4ff';
            });
            
            fileInputDisplay.addEventListener('dragleave', function(e) {
                e.preventDefault();
                this.style.borderColor = '#667eea';
                this.style.background = '#f8f9ff';
            });
            
            fileInputDisplay.addEventListener('drop', function(e) {
                e.preventDefault();
                this.style.borderColor = '#667eea';
                this.style.background = '#f8f9ff';
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const fileInput = document.getElementById('archivo_excel');
                    fileInput.files = files;
                    
                    // Trigger change event
                    const event = new Event('change', { bubbles: true });
                    fileInput.dispatchEvent(event);
                }
            });
            
            // Add smooth scrolling to table
            const tableScroll = document.querySelector('.table-scroll');
            if (tableScroll) {
                tableScroll.style.scrollBehavior = 'smooth';
            }
        });
    </script>
</body>
</html>
